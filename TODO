
Parsing of multiple ifs is not good, fix it

GTK callback no longer works

Optimize return cell_ref(hash_void); // error

Restore end recursion  https://en.wikipedia.org/wiki/Tail_call

Ellipsis is 3 dots?

Get rid of pair, instead : is c_LABEL (only in some instances)
Haskell uses : as cons operator, though

Does not parse: -12 / 4;

Also: 35: instead of 35; is strange

Env is a structure with misc state info?

Quote should be on both sides? Practical?

[] should continue parsing...

Functions within assocs must be able to refer to their own assoc

|-operator is for replacements, so somewhat related to &.

How to deal with io etc. not being pure functions?

Lists and assocs can also be used for functions. Skip [] operator?

[] is NIL, maybe also {} ??
Delay creation of assoc list?

Lists and vectors are the same, so drop lists (make it up to runtime to switch)

Invocations of eval still uses C stack, so still not proper end recursion

DO not have pair as a data type using :. Instead, : is a label data type (left side quoted).

Possibly implement semicolon as operator like C comma operator
Needs some refinement for sure

When array and assoc initialization is Json style,
how to separate a {} block in a program from an initialized assoc?

Json keys are always strings. Reserved names and types:
    null, true, false
    signed decimal number, including floats
    string
    array [] and comma-separated elements.
    associative array

{} is an empty assoc?
What is the difference between (){} for function and {} for assoc, really.
Try to nullify it. So in addition to { a : b }, we can also have { a }
which means? And { a ; b }

The & operator can update values in assocs? Probably | is better! What about vectors?

Fully implement function call without use of C stack

c_STRING8
c_STRING16
c_STRING24?
c_STRINGU // UTF8

Implement non-mutable 'variables'

TODO allow for byte order mark and other Unicode stuff in reader

Assoc keys can be symbols, integers. Or strings?

Have === operator in addition to ==. === corresponds to eq? in Scheme,
while == corresponds to eqv? (egual value). (There is no equal?)

In Scheme, 'display' will print strings without the " etc while 'write' will
write S-expressions that 'read' can read. We should be able to read JSON 
directly.

List functions: map

ELM and Haskell uses ++ instead of & to concatenate.

Do we really need lists and vectors to be different things???

Easy to use threading, like goroutines, i.e.: go function() i.e. !! function()

Go interfaces - specifies only functions

In error messages,
should prettyprint instead, so instead of #(#defq, a, b) say a = b

Readline tab completion could perhaps understand "io." and more of syntax

Sort assocs when printing (by default) to stabilize output generated

Speed up env_progp-based loop etc

Improve GCD algorithm? Method of least absolute remainders https://en.wikipedia.org/wiki/Euclidean_algorithm

Should boolean be a separate type? May still make sense to refer to the same cells

Allow infinite as a number?

Compare strings with NUL (so use memcmp instead of strcmp)

TODO what to do about integer overflow? Convert to float?

#include("filename");

Vector/list and function subscript is the same? So fib(0..10) returns a vector

Erlang example of how to deal with lists:


qsort([]) -> []; % If the list [] is empty, return an empty list (nothing to sort)
qsort([Pivot|Rest]) ->
    % Compose recursively a list with 'Front' for all elements that should be before 'Pivot'
    % then 'Pivot' then 'Back' for all elements that should be after 'Pivot'
    qsort([Front || Front <- Rest, Front < Pivot]) ++
    [Pivot] ++
    qsort([Back || Back <- Rest, Back >= Pivot]).

we could do:

    pivot = math.div(#len(lst), 2); // how?
    qsort(lst[0 .. pivot.1]) & lst[pivot] & qsort(lst[pivot .. ])

Symbols can be called atoms

A continuation is also called a closure.

Funtional programming vz imperative.
Assocs are called Maps in Erlang.

Maybe #length should be some sort of operator? Hash?

Allow ref to as-of-yet undefined functions

Div and mod as operators?

Write to stream instead of number2string-conversion, anv vv read from stream

Mechanisms to deal with non-pure stuff:
      * https://en.wikipedia.org/wiki/Purely_functional_programming
      * Monads (Haskell +) https://en.wikipedia.org/wiki/Monad_(functional_programming)
      * I/O Monad https://en.wikipedia.org/wiki/Monad_(functional_programming)#IO_monad
      * https://en.wikipedia.org/wiki/Uniqueness_type (Clean)
      * https://en.wikipedia.org/wiki/Effect_system
      * Clojure ???
      * Declare as mutable (F#)
      * Erlang
