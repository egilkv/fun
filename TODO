
SQL insert leaks memory:
    s = #use("sqlite").open("sqlite.sql");
    s.insert("t1", { a:1, b:"BB", c:"3", d:[] });
cell is c_STOP

open/write/close also leaks

GTK stopped working

Revise syntaxm swop args, align with monads
	a = #bind(value, assoc-of-functions)
    means that
	a.func(b,c); same as func(a,b,c)
    and
	a = #bind(value, function)
    means that
	a(b,c); same as func(a,b,c)
Implement for io and GTK

cell_unref(d)   -> cell_dispose(&d)  unref and set to NIL so we dont accidentaly reuse

monad, can also be called effects?
bind operator >>= "shove" we can use that
The operator >> throws away results
But how to define the Monad workings? we need to be able to:
	instantiate it
	get its ac

Simple Monad example is Maybe, which can be Just value, or Nothing (usu. meaning error)
IO is also a monad which can be exceptions  https://wiki.haskell.org/Introduction_to_IO
A value (IO a) is an action which will produce a value type a

https://medium.com/swlh/monads-in-python-e3c9592285d6

In Haskell, the Lambda operator is \

IO with binds:
main = putStrLn "Hello, what is your name?"
      >> getLine
      >>= \name -> putStrLn ("Hello, " ++ name ++ "!")

IO with do notation:
main = do putStrLn "Hello, what is your name?"
	  name <- getLine
	  putStrLn ("Hello, " ++ name ++ "!")

Perhaps {} is the same as DO notation??

sqlite:
	columns should return assoc with key:type

In Python, 'self' is referrence to our own structure

breakpoint/debugger works by moving the current function out of context and to
a debug_list similar to the ready_list

run_main if there is a run_main already, just places the new thing on the ready list
and returns immediately. Only problem is activate.
Locks around run_environment are shady

Avoid DOOOP in compile && and !!

F# cheat sheet:
https://raw.githubusercontent.com/dungpa/fsharp-cheatsheet/gh-pages/fsharp-cheatsheet.pdf

demo.fun only works if #include()

ref_range2: what about zero or negative len
optimize c_range with
	struct {
	    integer_t lower;
	    integer_t upper;
	} range;
#define RANGE_UNDEF -1

The time() thing should probably be outright replaced by:
	t0 = time.seconds();
	func();
	toime.seconds() - t0;

Remove
void run_main_apply(cell *lambda, cell *args) {
see also known_thunk_a to see if it can be used
compile as:
        push negative time now on stack (as func return value!)
        insert this program:
            call function -- known_thunk_a()
            discard return value
            call #use("time").seconds, pushing value
            call #plus

gtk.application_run(app, #args); should be a separate thread of some kind
SO that it can be started with a #go, and that it returns nicely when done.
Perhaps using an internal channel or something

GTK magic unref does not work at all?

Have special channel types with C functions as senders and as receivers

Change push_nothing to a special class of function

Add buffering to stdout

Second error message not needed
    #apply(#plus) ==> error; missing tail arguments: []
    +error; not a function with N args: #cfun()

See if locks can be replaces by atomics
https://en.cppreference.com/w/c/atomic
Fix locking in run.c and elsewhere
Also probably needs a few volatile declarations

Channels can be buffered, with a certain length given.
Senders can close a channel
https://tour.golang.org/concurrency/4

Have special type of list with pointer to last element, for FIFO use. Examples
are ready_list, schannel and so on

Proposal:
	std = #use("std");
	std.out <- "Hello world";
	readstring = <- std.in;
	#print converts args to string (with optional formatting), as does #write


Rewrite debugger so that it places main on the ready list instead of the save thing.

interrupt and run_main_apply should be consolidated.

We need some way of handling run_main being idle, and also have readline as a separate
process probably transferring what we read through a channel?

Add debugger and #breakpoint(). Option to switch to debugger on error.
Debugger should have functions to look at locals in run_environment->env
Also show what is in run_environment->prog and run_environment->save
even run_environment->stack
Maybe make #breakpoint() a special opcode debug opcode, that halts operation.
Can be used for conditional trace and breakpoints, gets rid of closure0t.
One other option is to make a new frame for breakpoint that essentially is a copy of
the current one, with pointer to same assoc and continuation.
#trace(a,b,c) should print a,b,c and return value of c ????

Add line number and filename info to each program node.
23 bits?
10 bits lineno, 1000 lines
7 bits colno, 128 columns
6 bits fileno, 64 files?
Alternatively, have large array of locations, and an increasing index# to that-
Uses lots of memory, but super capacity. or use 64 bits in cell.
Each location is e.g. 32 bits, with lineno, colno, fileno
Or even with file index, for lazy random access.

'[1, 2]   becomes  #list(1, 2).  Really?
'1+2      becomes  #plus(1, 2).  Really?

Stack in run should be conventional stack, i.e. vector that may be reallocated?
Much faster, presumably

Optimize away globals that are immutable. Plus locals?

Have defq for globals and defq for locals

During garbage collect, do not forget:
	run_environment_sweep(run_environment);

Consider not calling a func if args produced errors. Fix to if may help a lot, though.

Printing label stuff, add parens:
	[ a: 2, b: 3 ]
	[ (a: 2), (b: 3) ]

How to deal with back and forth local refs? Maybe this:
	a = #undefined;
	b = (){ something(a) };
	a = (){ something(b) };

Do not allow run(), instead insert another level or another tread...

All print/write functions generate strings which are then channeled to files

Parsing of code {} within {} is pretty broken, see qsort-new.fun

Variadic function cannot be mixed with labels?
What about ... = Also ... cannot be used as labels
For variadic functions, Python uses this, which is better
	function variadic_function($a, $b, ...$other) {
		return $other;
	}
	var_dump(variadic_function(1, 2, 3, 4, 5));
Variadic functions: fn = (a b & c) where c contains a list of the resto of the params

Have special symbol that means myself, i.e. own function, e.g. #self
In clojure, 'recur' is to call itself. We should have something alike. E.g. #self

Clean up calln.cdr usage

Self referrences should default to weak refs.
How to make weak bindings for local closures.
keyval -> keyweak
HAVE_WEAK for now disabled

Div and mod as operators, e.g. /% and %

2^;

get_integer() -> get_anyinteger()

<something> is also a syntax to consider

Suggest |-operator for replacements, so somewhat related to &.

If ++ is catenation, then +- could be replacements for vectors and assocs
Then -- could be to remove whatever...
(The ++ operator can update values in assocs? Probably | is better! What about vectors?
How to deal with duplicate keys on ++)
Alternative is & for catenation | for replacements, perhaps ~ for removals;

list(1..)
list(0..0)
Array indexing can also be done by (), as a function arg. Maybe skip [] altogether.
b = [1, 2, 3];
b(1);
Consider: Second argument is default value if lookup fail (for assocs and lists)
Consider: NIL as first argument

Clojure stores state in ATOMs, uses swap! function with current value as arg,
next value as result.

Should we have sets, which are essentialls assocs with keys but no vals,
or are assoc sufficient
How to check if a set contains an element #contains() ? Or use #try

"Associate" is the same as adding to assocs
The map can be used as a function. Maybe that is the preferred or only way?

#void should have something that suppresses further error messages

When pasting readline interprets TAB characters at start of line
Single ; should maybe be void?
Ranges as function arguments does not work. Maybe they should.

Enable in-line for #if
#if 0 // TODO enable...

Clojure:
Quotient is that called a ratio? Assoc is that a map
#doc(func) shows documentation
*1 is the latest result
#length is called count, which is better, really
Catenate is called conjoin

Modules. Namespaces?

These are the same, not currently supported (and perhaps needless, catenate is easy)
#apply(f, [1, 2, 3, 4])
#apply(f, 1, 2, [3, 4])
#apply(f, 1, 2, 3, 4, [])
f(1, 2, 3, 4)

When should the thing ahead of : be evaluated?
name: "Alice"
(name): "Alice"
10: "Tenth"
10-1: "Ninth"
(10-1): "Ninth"     Is maybe a compromise??

Haskell uses : as cons operator, TBD

Also: 35: instead of 35; is strange

Env is a structure with misc state info?

Quote should be on both sides? Practical?

OK? [] should continue parsing...

Functions within assocs must be able to refer to their own assoc?

Lists and assocs can also be used for functions. Skip [] operator?

[] is NIL, maybe also {} ??
Delay creation of assoc list?

Possibly implement semicolon as operator like C comma operator
Needs some refinement for sure

When array and assoc initialization is Json style,
how to separate a {} block in a program from an initialized assoc?

Json keys are always strings. Reserved names and types:
    null, true, false
    signed decimal number, including floats
    string
    array [] and comma-separated elements.
    associative array

{} is an empty assoc?
What is the difference between (){} for function and {} for assoc, really.
Try to nullify it. So in addition to { a : b }, we can also have { a }
which means? And { a ; b }

Vector/list and function subscript is the same? So fib(0..10) returns a vector?
Should be #map instead, or some operator

c_STRING8
c_STRING16
c_STRING24?
c_STRINGU // UTF8

Fully implement non-mutable 'variables'

TODO allow for byte order mark and other Unicode stuff in reader

Assoc keys can be symbols. Strings are demoted to symbols. Integers are for vectors.

Have === operator in addition to ==. === corresponds to eq? in Scheme,
while == corresponds to eqv? (egual value). (There is no equal?)

In Scheme, 'display' will print strings without the " etc while 'write' will
write S-expressions that 'read' can read. We should be able to read JSON 
directly.

List functions: map

Sanity check symbol!?
a = { "one": 1 };
a."one";
a["one"];

ELM and Haskell uses ++ instead of & to concatenate.

In error messages,
should prettyprint instead, so instead of #(#defq, a, b) say a = b

Readline tab completion could perhaps understand "io." and filenames and more of syntax

Speed up env_progp-based loop etc

Improve GCD algorithm? Method of least absolute remainders https://en.wikipedia.org/wiki/Euclidean_algorithm

Should boolean be a separate type? May still make sense to refer to the same cells

Allow infinite as a number?

Compare strings with NUL-characters in them (so use memcmp instead of strcmp)

TODO what to do about integer overflow? Convert to float?

A continuation is also called a closure.
Funtional programming vz imperative.
Assocs are called Maps in Erlang.
Symbols can be called atoms

Maybe #count() should be some sort of operator? Hash something? #(array)

Div and mod as operators?

Write to stream instead of number2string-conversion, anv vv read from stream

How to deal with io etc. not being pure functions?
Mechanisms to deal with non-pure stuff:
      * https://en.wikipedia.org/wiki/Purely_functional_programming
      * Monads (Haskell +) https://en.wikipedia.org/wiki/Monad_(functional_programming)
      * I/O Monad https://en.wikipedia.org/wiki/Monad_(functional_programming)#IO_monad
      * https://en.wikipedia.org/wiki/Uniqueness_type (Clean)
      * https://en.wikipedia.org/wiki/Effect_system
      * Clojure ???
      * Declare as mutable (F#)
      * Erlang

Are symbols with values really functions that define the same value every time??

Quoting operators: '+ same as #plus and so on?

Implement &, | and ^ as homage to C?
Throw away bit.and, bit.or etc
Let "bit" also work for Booleans
#type #t #f #void what are they? What is #type([])

How to do switches efficiently

Can we index a range? Is it meaningful

Implement lazy sequences etc

Add #eval? Or not

Have #assert()
Have #error()

Optimize #type

Warning if = used instead of ==

#include should return result

Should this be possible?
    #apply(#plus, [1, 2, 3]);
    #apply(#plus, (1..3));

Parsing error, check
     '+;
