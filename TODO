
Rewrite debugger so that it places main on the ready list instead of the save thing.

Add debugger and #breakpoint(). Option to switch to debugger on error.
Debugger should have functions to look at locals in run_environment->env
Also show what is in run_environment->prog and run_environment->save
even run_environment->stack
Maybe make #breakpoint() a special opcode debug opcode, that halts operation.
Can be used for conditional trace and breakpoints, gets rid of closure0t.
One other option is to make a new frame for breakpoint that essentially is a copy of
the current one, with pointer to same assoc and continuation.
#trace(a,b,c) should print a,b,c and return value of c ????

Add line number and filename info to each program node.
23 bits?
10 bits lineno, 1000 lines
7 bits colno, 128 columns
6 bits fileno, 64 files?
Alternatively, have large array of locations, and an increasing index# to that-
Uses lots of memory, but super capacity. or use 64 bits in cell.
Each location is e.g. 32 bits, with lineno, colno, fileno
Or even with file index, for lazy random access.

'[1, 2]   becomes  #list(1, 2).  Really?
'1+2      becomes  #plus(1, 2).  Really?

Stack in run should be conventional stack, i.e. vector that may be reallocated?
Much faster, presumably

Optimize away globals that are immutable. Plus locals?

Have defq for globals and defq for locals

During garbage collect, do not forget:
	run_environment_sweep(run_environment);

This really, really should yield void if A2 is unknown
A2 == B2 ? "same":"not";
Do not recurse if args produced errors. Fix to if mayy help a lot,
see above.

Printing label stuff, add parens:
	[ a: 2, b: 3 ]
	[ (a: 2), (b: 3) ]

How to deal with back and forth local refs? Maybe this:
	a = #undefined;
	b = (){ something(a) };
	a = (){ something(b) };

Do not allow run(), instead insert another level or another tread...

All print/write functions generate strings which are then channeled to files

Parsing of code {} within {} is pretty broken, see qsort-new.fun

Variadic function cannot be mixed with labels?
What about ... = Also ... cannot be used as labels
For variadic functions, Python uses this, which is better
	function variadic_function($a, $b, ...$other) {
		return $other;
	}
	var_dump(variadic_function(1, 2, 3, 4, 5));
Variadic functions: fn = (a b & c) where c contains a list of the resto of the params

Have special symbol that means myself, i.e. own function, e.g. #self
In clojure, 'recur' is to call itself. We should have something alike. E.g. #self

Clean up calln.cdr usage

Self referrences should default to weak refs.
How to make weak bindings for local closures.
keyval -> keyweak
HAVE_WEAK for now disabled

Div and mod as operators, e.g. /% and %

2^;

get_integer() -> get_anyinteger()

<something> is also a syntax to consider

Suggest |-operator for replacements, so somewhat related to &.

If ++ is catenation, then +- could be replacements for vectors and assocs
Then -- could be to remove whatever...
(The ++ operator can update values in assocs? Probably | is better! What about vectors?
How to deal with duplicate keys on ++)
Alternative is & for catenation | for replacements, perhaps ~ for removals;

list(1..)
list(0..0)
Array indexing can also be done by (), as a function arg. Maybe skip [] altogether.
b = [1, 2, 3];
b(1);
Consider: Second argument is default value if lookup fail (for assocs and lists)
Consider: NIL as first argument

Clojure stores state in ATOMs, uses swap! function with current value as arg,
next value as result.

Should we have sets, which are essentialls assocs with keys but no vals,
or are assoc sufficient
How to check if a set contains an element #contains() ? Or use #try

"Associate" is the same as adding to assocs
The map can be used as a function. Maybe that is the preferred or only way?

#void should have something that suppresses further error messages

When pasting readline interprets TAB characters at start of line
Single ; should maybe be void?
Ranges as function arguments does not work. Maybe they should.

Enable in-line for #if
#if 0 // TODO enable...

Clojure:
Quotient is that called a ratio? Assoc is that a map
#doc(func) shows documentation
*1 is the latest result
#length is called count, which is better, really
Catenate is called conjoin

Modules. Namespaces?

These are the same, not currently supported (and needless, catenate is easy)
#apply(f, [1, 2, 3, 4])
#apply(f, 1, 2, [3, 4])
#apply(f, 1, 2, 3, 4, [])
f(1, 2, 3, 4)

When should the thing ahead of : be evaluated?
name: "Alice"
(name): "Alice"
10: "Tenth"
10-1: "Ninth"
(10-1): "Ninth"     Is maybe a compromise??

Haskell uses : as cons operator, TBD

Also: 35: instead of 35; is strange

Env is a structure with misc state info?

Quote should be on both sides? Practical?

OK? [] should continue parsing...

Functions within assocs must be able to refer to their own assoc?

Lists and assocs can also be used for functions. Skip [] operator?

[] is NIL, maybe also {} ??
Delay creation of assoc list?

Possibly implement semicolon as operator like C comma operator
Needs some refinement for sure

When array and assoc initialization is Json style,
how to separate a {} block in a program from an initialized assoc?

Json keys are always strings. Reserved names and types:
    null, true, false
    signed decimal number, including floats
    string
    array [] and comma-separated elements.
    associative array

{} is an empty assoc?
What is the difference between (){} for function and {} for assoc, really.
Try to nullify it. So in addition to { a : b }, we can also have { a }
which means? And { a ; b }

Vector/list and function subscript is the same? So fib(0..10) returns a vector??

c_STRING8
c_STRING16
c_STRING24?
c_STRINGU // UTF8

Fully implement non-mutable 'variables'

TODO allow for byte order mark and other Unicode stuff in reader

Assoc keys can be symbols. Strings are demoted to symbols. Integers are for vectors.

Have === operator in addition to ==. === corresponds to eq? in Scheme,
while == corresponds to eqv? (egual value). (There is no equal?)

In Scheme, 'display' will print strings without the " etc while 'write' will
write S-expressions that 'read' can read. We should be able to read JSON 
directly.

List functions: map

Sanity check symbol!?
a = { "one": 1 };
a."one";
a["one"];

ELM and Haskell uses ++ instead of & to concatenate.

Easy to use threading, like goroutines, i.e.: go function() i.e. !! function()

Go interfaces - specifies only functions

In error messages,
should prettyprint instead, so instead of #(#defq, a, b) say a = b

Readline tab completion could perhaps understand "io." and filenames and more of syntax

Speed up env_progp-based loop etc

Improve GCD algorithm? Method of least absolute remainders https://en.wikipedia.org/wiki/Euclidean_algorithm

Should boolean be a separate type? May still make sense to refer to the same cells

Allow infinite as a number?

Compare strings with NUL-characters in them (so use memcmp instead of strcmp)

TODO what to do about integer overflow? Convert to float?

A continuation is also called a closure.
Funtional programming vz imperative.
Assocs are called Maps in Erlang.
Symbols can be called atoms

Maybe #count() should be some sort of operator? Hash something? #(array)

Div and mod as operators?

Write to stream instead of number2string-conversion, anv vv read from stream

How to deal with io etc. not being pure functions?
Mechanisms to deal with non-pure stuff:
      * https://en.wikipedia.org/wiki/Purely_functional_programming
      * Monads (Haskell +) https://en.wikipedia.org/wiki/Monad_(functional_programming)
      * I/O Monad https://en.wikipedia.org/wiki/Monad_(functional_programming)#IO_monad
      * https://en.wikipedia.org/wiki/Uniqueness_type (Clean)
      * https://en.wikipedia.org/wiki/Effect_system
      * Clojure ???
      * Declare as mutable (F#)
      * Erlang

Are symbols with values really functions that define the same value every time??

Quoting operators: '+ same as #plus and so on?

Implement &, | and ^ as homage to C?
Throw away #bitand, #bitor etc

Let "bit" also work for Booleans
#type #t #f #void what are they? What is #type([])

How to do switches efficiently

Can we index a range? Is it meaningful

Implement lazy sequences etc

Proposal: 
	1..100[0] ==> 1 
	1..100[1..] ==> 2..100
	100.100[1..] ==> []

Add #eval? Or not

Have #assert()

Optimize #type
