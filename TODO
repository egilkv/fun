
'[1, 2]   becomes  #list(1, 2).  Really?
'1+2      becomes  #plus(1, 2).  Really?

Optimize away globals that are immutable. Plus locals

Optimize range, for istance

Do not allow run(), instead insert another level or another tread...

Do not recurse if args produced errors

Parsing of code {} within {} is pretty broken, see qsort-new.fun

Variadic function cannot be mixed with labels?

What about ... = Also ... cannot be used as labels
For variadic functions, Python uses this, which is better
	function variadic_function($a, $b, ...$other) {
		return $other;
	}
	var_dump(variadic_function(1, 2, 3, 4, 5));
Variadic functions: fn = (a b & c) where c contains a list of the resto of the params

Have special symbol that means myself, i.e. own function, e.g. #self
In clojure, 'recur' is to call itself. We should have something alike. E.g. #self

Clean up calln.cdr usage

Self referrences should default to weak refs.
How to make weak bindings for local closures.
keyval -> keyweak
HAVE_WEAK for now disabled

list[1..] 
list(0..0)

trace(a,b,c) should print a,b,c and return value of c

Div and mod as operators, e.g. /% and %

2^;

get_integer() -> get_anyinteger()

Suggest |-operator for replacements, so somewhat related to &.

Compiler should resolve all local variables. And optimize whether an environment is 
requried at all for a function.

<something> is also a syntax to consider

If ++ is catenation, then +- could be replacements for vectors and assocs
Then -- could be to remove whatever...
(The ++ operator can update values in assocs? Probably | is better! What about vectors?
How to deal with duplicate keys on ++)
Alternative is & for catenation | for replacements, perhaps ~ for removals;

Array indexing can also be done by (), as a function arg. Maybe skip [] altogether.
b = [1, 2, 3];
b(1);
Consider: Second argument is default value if lookup fail (for assocs and lists)
Consider: NIL as first argument

Clojure stores state in ATOMs, uses swap! function with current value as arg,
next value as result.

Should we have sets, which are essentialls assocs with keys but no vals,
or are assoc sufficient
How to check if a set contains an element #contains() ? Or use #try

"Associate" is the same as adding to assocs
The map can be used as a function. Maybe that is the preferred or only way?

#void should have something that suppresses further error messages

When pasting readline interprets TAB characters at start of line
Single ; should maybe be void?
Ranges as function arguments does not work. Maybe they should.

Enable in-line for #if
#if 0 // TODO enable...

Returning arg in m_gtk, is that really smart?

Clojure:
Quotient is that called a ratio? Assoc is that a map
#doc(func) shows documentation
*1 is the latest result
#length is called count, which is better, really
Catenate is called conjoin

Modules. Namespaces?

These are the same:
#apply(f, [1, 2, 3, 4])
#apply(f, 1, 2, [3, 4])
#apply(f, 1, 2, 3, 4, [])
f(1, 2, 3, 4)

When should the thing ahead of : be evaluated?
name: "Alice"
(name): "Alice"
10: "Tenth"
10-1: "Ninth"
(10-1): "Ninth"     Is maybe a compromise??

Haskell uses : as cons operator, TBD

Also: 35: instead of 35; is strange

Env is a structure with misc state info?

Quote should be on both sides? Practical?

OK? [] should continue parsing...

Functions within assocs must be able to refer to their own assoc?

Lists and assocs can also be used for functions. Skip [] operator?

[] is NIL, maybe also {} ??
Delay creation of assoc list?

Possibly implement semicolon as operator like C comma operator
Needs some refinement for sure

When array and assoc initialization is Json style,
how to separate a {} block in a program from an initialized assoc?

Json keys are always strings. Reserved names and types:
    null, true, false
    signed decimal number, including floats
    string
    array [] and comma-separated elements.
    associative array

{} is an empty assoc?
What is the difference between (){} for function and {} for assoc, really.
Try to nullify it. So in addition to { a : b }, we can also have { a }
which means? And { a ; b }

Vector/list and function subscript is the same? So fib(0..10) returns a vector??

Fully implement function call without use of C stack

c_STRING8
c_STRING16
c_STRING24?
c_STRINGU // UTF8

Fully implement non-mutable 'variables'

TODO allow for byte order mark and other Unicode stuff in reader

Assoc keys can be symbols. Strings are demoted to symbols. Integers are for vectors.

Have === operator in addition to ==. === corresponds to eq? in Scheme,
while == corresponds to eqv? (egual value). (There is no equal?)

In Scheme, 'display' will print strings without the " etc while 'write' will
write S-expressions that 'read' can read. We should be able to read JSON 
directly.

List functions: map

Sanity check symbol!?
a = { "one": 1 };
a."one";
a["one"];

ELM and Haskell uses ++ instead of & to concatenate.

Easy to use threading, like goroutines, i.e.: go function() i.e. !! function()

Go interfaces - specifies only functions

In error messages,
should prettyprint instead, so instead of #(#defq, a, b) say a = b

Readline tab completion could perhaps understand "io." and filenames and more of syntax

Speed up env_progp-based loop etc

Improve GCD algorithm? Method of least absolute remainders https://en.wikipedia.org/wiki/Euclidean_algorithm

Should boolean be a separate type? May still make sense to refer to the same cells

Allow infinite as a number?

Compare strings with NUL-characters in them (so use memcmp instead of strcmp)

TODO what to do about integer overflow? Convert to float?

A continuation is also called a closure.
Funtional programming vz imperative.
Assocs are called Maps in Erlang.
Symbols can be called atoms

Maybe #count() should be some sort of operator? Hash something? #(array)

Div and mod as operators?

Write to stream instead of number2string-conversion, anv vv read from stream

How to deal with io etc. not being pure functions?
Mechanisms to deal with non-pure stuff:
      * https://en.wikipedia.org/wiki/Purely_functional_programming
      * Monads (Haskell +) https://en.wikipedia.org/wiki/Monad_(functional_programming)
      * I/O Monad https://en.wikipedia.org/wiki/Monad_(functional_programming)#IO_monad
      * https://en.wikipedia.org/wiki/Uniqueness_type (Clean)
      * https://en.wikipedia.org/wiki/Effect_system
      * Clojure ???
      * Declare as mutable (F#)
      * Erlang

Are symbols with values really functions that define the same value every time??

Quoting operators: '+ same as #plus and so on?

Implement &, | and ^ as homage to C?
Throw away #bitand, #bitor etc

Let "bit" also work for Booleans
#type #t #f #void what are they? What is #type([])

How to do switches efficiently

Can we index a range? Is it meaningful

Implement lazy sequences etc

Proposal: 
	1..100[0] ==> 1 
	1..100[1..] ==> 2..100
	100.100[1..] ==> []

Add #eval
