#defq(a, 1) ==> 1
#defq(b, 2) ==> 2
#defq(c, #lt(a, b)) ==> #t
#plus(a, b) ==> 3
#plus(a, b) ==> 3
#plus(a, b) ==> 3
#if(c, a, b) ==> 1
#defq(factorial, #lambda([ n ], #if(#lt(n, 2), 1, #times(n, factorial(#minus(n, 1)))))) ==> #closure0(
  args: [ n ]
) 
factorial(10) ==> 3628800
#defq(ft, #lambda([ a, b ], #defq(c, a), #defq(d, b), #plus(c, d))) ==> #closure0(
  args: [ a, b ]
) 
ft(50, 5) ==> 55
#defq(v, #list(7, 8, "hello")) ==> [ 7, 8, "hello" ]
#ref(v, 0) ==> 7
#ref(v, 2) ==> "hello"
#defq(aa, #assoc(one: 1, two: 2, three: 3)) ==> { 
  one: 1,
  three: 3,
  two: 2
} 
#defq(ix, #quote(two)) ==> two
#ref(aa, #quote(one)) ==> 1
#ref(aa, ix) ==> 2
#ref(aa, #quote(three)) ==> 3
#refq(aa, one) ==> 1
#refq(aa, two) ==> 2
#refq(aa, three) ==> 3
#cat(aa, #assoc(four: "FOUR")) ==> { 
  four: "FOUR",
  one: 1,
  three: 3,
  two: 2
} 
#cat(aa, #assoc(two: "TWO")) ==> error; duplicate key ignored: two
{ 
  one: 1,
  three: 3,
  two: 2
} 
#list(3: 99, 0: "test") ==> [ 0: "test", #undefined, #undefined, 99 ] 
#defq(list, #list(1, 2, 3)) ==> [ 1, 2, 3 ]
#ref(list, 0) ==> 1
#refq(list, 0) ==> 1
#cat("abc", "def") ==> "abcdef"
#ref("abcdef", 2) ==> "c"
#defq(array1, #list(1, 2, 3, 4, 5, 6)) ==> [ 1, 2, 3, 4, 5, 6 ]
#ref(array1, 0) ==> 1
#ref(array1, 3) ==> 4
#ref(array1, 3 .. 4) ==> [ 4, 5 ]
#defq(a, #list(0 .. #minus(10, 1): #t)) ==> [ 0: #t, #t, #t, #t, #t, #t, #t, #t, #t, #t ] 
#defq(j, 5) ==> 5
#cat(#ref(a,  .. 4), #list(#f), #ref(a, 6 .. )) ==> [ 0: #t, #t, #t, #t, #t, #f, #t, #t, #t, #t ] 
#cat(#ref(a,  .. #minus(j, 1)), #list(#f), #ref(a, #plus(j, 1) .. )) ==> [ 0: #t, #t, #t, #t, #t, #f, #t, #t, #t, #t ] 
#defq(f, #defq(g, 9)) ==> 9
#plus(g, f, 12) ==> 30
#minus(#plus(g, f, 12), 30) ==> 0
#bitxor(2, #quotient(50, 2)) ==> error; not a function with 2 args: #undefined
undefined ==> #undefined
#defq(io, #use("io")) ==> { 
  getline: #cfun(),
  print: #cfun(),
  println: #cfun(),
  read: #cfun(),
  write: #cfun(),
  writeln: #cfun()
} 
#defq(text1, "ECHO") ==> "ECHO"
#defq(text2, "DELTA") ==> "DELTA"
#defq(invoke, #lambda([ fn ], #defq(text1, "BOB"), #defq(text2, "CAROLINE"), fn(), text2)) ==> #closure0(
  args: [ fn ]
) 
invoke(#lambda([], #refq(io, println)("case 1 is ", text1, " and ", text2))) ==> case 1 is ECHO and DELTA
"CAROLINE"
#defq(func, #lambda([], #defq(text1, "ALICE"), invoke(#lambda([], #refq(io, println)("case 2 is ", text1, " and ", text2))))) ==> #closure0(
  args: []
) 
func() ==> case 2 is ALICE and DELTA
"CAROLINE"
#lambda([ text2 ], invoke(#lambda([], #refq(io, println)("case 3 is ", text1, " and ", text2))))("ZZZ") ==> case 3 is ECHO and ZZZ
"CAROLINE"
-3 ==> -3
#times(12345678.901234, 100000) ==> 1234567890123.4
#plus(#quotient(1, 2), 1/3) ==> 5/6
#plus(#quotient(1.0, 2), 1/3) ==> 0.833333333333333
#minus(#quotient(1, 2), 0.5) ==> 0.0
#defq(m, #use("math")) ==> { 
  abs: #cfun(),
  acos: #cfun(),
  asin: #cfun(),
  atan: #cfun(),
  atan2: #cfun(),
  ceil: #cfun(),
  cos: #cfun(),
  div: #cfun(),
  e: 2.71828182845905,
  floor: #cfun(),
  int: #cfun(),
  log: #cfun(),
  log10: #cfun(),
  mod: #cfun(),
  pi: 3.14159265358979,
  pow: #cfun(),
  sin: #cfun(),
  sqrt: #cfun(),
  tan: #cfun()
} 
#refq(m, sqrt)(2) ==> 1.4142135623731
#refq(m, sqrt)(-2) ==> error; no real square root
#refq(m, e) ==> 2.71828182845905
#refq(m, sin)(#quotient(#refq(m, pi), 2)) ==> 1.0
#refq(m, tan)(#quotient(#refq(m, pi), 4)) ==> 1.0
#refq(m, tan)(#quotient(#refq(m, pi), 2)) ==> 1.63312393531954e+16
#refq(m, atan)(9999999999999) ==> 1.5707963267948
#refq(m, pow)(10, 9) ==> 1000000000.0
#refq(m, pow)(10, 90) ==> 1e+90.0
#refq(m, pow)(10, 900) ==> error; pow out of range
#refq(m, pow)(-10, 9) ==> -1000000000.0
#refq(m, pow)(10, -9) ==> 1e-09.0
#refq(m, abs)(-12.34) ==> 12.34
#refq(m, abs)(-12) ==> 12
#refq(m, abs)(-6/17) ==> 6/17
#refq(m, int)(12.1) ==> 12
#refq(m, int)(12.6) ==> 13
#refq(m, int)(-12.1) ==> -12
#refq(m, int)(-12.6) ==> -13
#refq(m, int)(10/3) ==> 3
#refq(m, int)(11/3) ==> 4
#lt("a", "b", "c") ==> #t
#lt("aa", "a") ==> #f
#lt("b", "a", "x") ==> #f
#defq(as, "abc") ==> "abc"
#defq(al, #list(1, 2, 3)) ==> [ 1, 2, 3 ]
#defq(av, #list(0: 1, 2, 3)) ==> [ 0: 1, 2, 3 ] 
#ref(as, 2 .. ) ==> "c"
#ref(al, 2 .. ) ==> [ 3 ]
#ref(av, 2 .. ) ==> [ 0: 3 ] 
#ref(as, 3 .. ) ==> ""
#ref(al, 3 .. ) ==> []
#ref(av, 3 .. ) ==> []
#ref(as, 4 .. ) ==> error; string range out of bounds: 4
#ref(al, 4 .. ) ==> error; list index out of bounds: 4
#ref(av, 4 .. ) ==> error; vector range out of bounds: 4
#ref(as, 2 .. 2) ==> "c"
#ref(al, 2 .. 2) ==> [ 3 ]
#ref(av, 2 .. 2) ==> [ 0: 3 ] 
#ref(as, 2 .. 3) ==> error; string range out of bounds: 3
#ref(al, 2 .. 3) ==> error; list range out of bounds: 3
#ref(av, 2 .. 3) ==> error; vector range out of bounds: 3
#ref(as, 3 .. 3) ==> error; string range out of bounds: 3
#ref(al, 3 .. 3) ==> error; list range out of bounds: 3
#ref(av, 3 .. 3) ==> error; vector range out of bounds: 3
#cat(#list(0: 1, 2, 3), #list(0: 4, 5)) ==> [ 0: 1, 2, 3, 4, 5 ] 
#cat(#list(1, 2, 3), #list(4, 5)) ==> [ 1, 2, 3, 4, 5 ]
#include("qsort.fun") ==> qsort(#list(5, 2, 7, 6, 3, 9, 12, 99, 1)) ==> [ 1, 2, 3, 5, 6, 7, 9, 12, 99 ]
qsort(#list("the", "quick", "brown", "fox", "jumps", "over", "a", "lazy", "dog")) ==> [ "a", "brown", "dog", "fox", "jumps", "lazy", "over", "quick", "the" ]
#defq(max, 9223372036854775807) ==> 9223372036854775807
#plus(max, 1) ==> error; numerical overflow
#minus(max) ==> -9223372036854775807
#minus(#minus(max), 1) ==> -9223372036854775808
#minus(#minus(max), 2) ==> error; numerical overflow
#refq(m, abs)(#minus(max)) ==> 9223372036854775807
#refq(m, abs)(#minus(#minus(max), 1)) ==> error; numerical overflow
#refq(m, int)(9.22337203685477e+18) ==> 9223372036854769664
#refq(m, int)(9.22337203685478e+18) ==> error; numerical overflow
#refq(m, int)(9.22337203685478e+18) ==> error; numerical overflow
#refq(m, int)(9.22337203685478e+18) ==> error; numerical overflow
#refq(m, int)(9.223372036855e+18) ==> error; numerical overflow
#refq(m, int)(-9.22337203685477e+18) ==> -9223372036854769664
#refq(m, int)(-9.22337203685478e+18) ==> error; numerical overflow
#refq(m, int)(3/2) ==> 2
#refq(m, int)(-3/2) ==> -2
#refq(m, int)(1/3) ==> 0
#refq(m, int)(2/3) ==> 1
#refq(m, int)(4/3) ==> 1
#refq(m, int)(5/3) ==> 2
#minus(-4, 1) ==> -5
#cat(#list(0: 1, 2, 3), #list(4, 5)) ==> [ 0: 1, 2, 3, 4, 5 ] 
#cat(#list(1, 2, 3), #list(0: 4, 5)) ==> [ 1, 2, 3, 4, 5 ]
qsort(#list(0: 5, 2, 7, 6, 3, 9, 12, 99, 1)) ==> [ 1, 2, 3, 5, 6, 7, 9, 12, 99 ]
#list(0 .. 3: 99, 100) ==> [ 0: 99, 99, 99, 99, 100 ] 
#list(0: 99, 3: 99, 100) ==> [ 0: 99, #undefined, #undefined, 99, 100 ] 
#list(0: 98,  .. 3: 99, 100) ==> [ 0: 98, 99, 99, 99, 100 ] 
#list(0: 98,  .. 3: 99, 100) ==> [ 0: 98, 99, 99, 99, 100 ] 
#list(0: 1.23, 2.34, 3: 3.14, 0: 2) ==> error; cannot redefine vector, index : 0
[ 0: 1.23, 2.34, #undefined, 3.14 ] 
#defq(messenger_builder, #lambda([ greeting ], #lambda([ who ], #refq(io, println)(greeting, " ", who)))) ==> #closure0(
  args: [ greeting ]
) 
#defq(hello_er, messenger_builder("Hello")) ==> #closure(
  args: [ who ]
  cont: #env(
    prev: []
    assoc: { 
        greeting: "Hello"
      } 
    cont: []
  )
) 
hello_er("world!") ==> Hello world!
#type("abc") ==> string
#type(hello_er) ==> closure
#type(list) ==> list
#type(1) ==> integer
#type(1.0) ==> real
#type(1/2) ==> ratio
#type(#quote(sym)) ==> symbol
#type(#type) ==> function
#type(#t) ==> boolean
#type(#void) ==> void
#type(akka) ==> undefined
#defq(time, #use("time")) ==> { 
  localtime: #cfun(),
  mktime: #cfun(),
  seconds: #cfun(),
  sleep: #cfun(),
  time: #cfun(),
  utctime: #cfun()
} 
#refq(time, utctime)(1622447459.9024) ==> { 
  hour: 7,
  isdst: #f,
  mday: 31,
  min: 50,
  mon: 5,
  sec: 59.9024,
  wday: 1,
  yday: 150,
  year: 2021
} 
#defq(lt, #refq(time, localtime)(1622447459.9024)) ==> { 
  hour: 9,
  isdst: #t,
  mday: 31,
  min: 50,
  mon: 5,
  sec: 59.9024,
  wday: 1,
  yday: 150,
  year: 2021
} 
#refq(time, mktime)(lt) ==> 1622447459
#defq(abc, #lambda([ a, b, c ], #plus(a, #times(b, #plus(c, 10))))) ==> #closure0(
  args: [ a, b, c ]
) 
#defq(aba, #lambda([ a, b, a ], #plus(a, #times(b, #plus(a, 5))))) ==> error; duplicate parameter name: a
#closure0(
  args: [ a, b, a ]
) 
abc(1, 2, 3) ==> 27
abc(c: 3, b: 2, a: 1) ==> 27
abc(1, c: 3, b: 2) ==> 27
abc(c: 3, a: 1, 2) ==> error; ignore unlabelled argument following labelled: 2
error; missing value for: b
error; not a number: #void
error; not a number: #void
abc(1, x: 3, b: 2) ==> error; no such parameter label: x
error; missing value for: c
error; not a number: #void
error; not a number: #void
error; not a number: #void
#defq(abc0, #lambda([ a: 10, b: 20, c: 30 ], #plus(a, #times(b, #plus(c, 10))))) ==> #closure0(
  args: [ a: 10, b: 20, c: 30 ]
) 
#defq(aba0, #lambda([ a: 10, b: 20, a: 30 ], #plus(a, #times(b, #plus(a, 10))))) ==> error; duplicate parameter name: a
#closure0(
  args: [ a: 10, b: 20, a: 30 ]
) 
#defq(ab0, #lambda([ a, b, 30 ], #plus(a, #times(b, #plus(a, 10))))) ==> error; parameter not a symbol: 30
#closure0(
  args: [ a, b, 30 ]
) 
abc0() ==> 810
abc0(b: 200) ==> 8010
abc0(1000) ==> 1800
abc0(1000, c: 300) ==> 7200
#defq(average, #lambda([ ... ], #quotient(#apply(#plus, ...), #count(...)))) ==> #closure0(
  args: [ ... ]
) 
average(11, 12, 12) ==> 35/3
average(11, 12, 12.0) ==> 11.6666666666667
#defq(add, #lambda([ ... ], #if(#eq(..., #list()), 0, #plus(#ref(..., 0), #apply(add, #ref(..., 1 .. )))))) ==> #closure0(
  args: [ ... ]
) 
add() ==> 0
add(1) ==> 1
add(1, 2, 3) ==> 6
#apply(#plus) ==> error; missing tail arguments: []
#apply(#plus, 1, 2, #list(3, 4, 5)) ==> error; excess argument(s) ignored: [ 2, #list(3, 4, 5) ]
error; apply argument not a list: 1
#times(#quotient(35, 3), 1.0) ==> 11.6666666666667
#defq(g, #lambda([ a, ... ], #cat(#list(a), #list(99), ...))) ==> #closure0(
  args: [ a, ... ]
) 
g(2, a: 3, 4) ==> [ 2, 99, a: 3, 4 ]
#defq(A, 1) ==> 1
#defq(B, 1) ==> 1
#defq(C, 2) ==> 2
#defq(D, 2) ==> 2
#and(#eq(A, B), #eq(C, D)) ==> #t
#and(#eq(1, 1), #eq(C, D)) ==> #t
#and(#eq(1, 2), #eq(C, D)) ==> #f
#and(#eq(2, 2), #eq(1, 1), #eq(C, D)) ==> #t
#and(#eq(1, A), #eq(2, A), #eq(C, D)) ==> #f
#eq(A2, B2) ==> error; cannot compare undefined: #undefined
#eq(A, A2) ==> error; cannot compare undefined: #undefined
#lt(A2, B2) ==> error; not a number: #undefined
#lt(A2, 1) ==> error; not a number: #undefined
#defq(fc, #lambda([ a ], #defq(b, #times(2, a)), #defq(g, #lambda([], b)), g())) ==> #closure0(
  args: [ a ]
) 
#defq(h, #lambda([], #times(10, fc(12)))) ==> #closure0(
  args: []
) 
h() ==> 240
#ref(1 .. 10, 0) ==> 1
#ref(1 .. 10, 1 .. ) ==> 2 .. 10
#ref(1 .. 2, 1 .. ) ==> 2 .. 2
#ref(1 .. 2, 2 .. ) ==> []
#defq(ct, #lambda([], #t)) ==> #closure0(
  args: []
) 
#defq(cf, #lambda([], #f)) ==> #closure0(
  args: []
) 
#defq(cv, #lambda([], #void)) ==> #closure0(
  args: []
) 
#defq(ff, #lambda([ n ], n)) ==> #closure0(
  args: [ n ]
) 
#if(ct(), ff(1), ff(0)) ==> 1
#if(cf(), ff(1), ff(0)) ==> 0
#if(cv(), ff(1), ff(0)) ==> error; not a boolean: #void
#and(cv(), ct()) ==> error; not a boolean: #void
#f
#and(cv(), cf()) ==> error; not a boolean: #void
#f
#or(cv(), ct()) ==> error; not a boolean: #void
#t
#or(cv(), cf()) ==> error; not a boolean: #void
#f
