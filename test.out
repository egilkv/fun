#defq(a, 1) ==> 1
#defq(b, 2) ==> 2
#defq(c, #lt(a, b)) ==> #t
#plus(a, b) ==> 3
#plus(a, b) ==> 3
#plus(a, b) ==> 3
#if(c, a, b) ==> 1
#defq(factorial, #lambda([ n ], #if(#lt(n, 2), 1, #times(n, factorial(#minus(n, 1)))))) ==> #closure0(
  args: [ n ]
  body: [ #if(#lt(n, 2), 1, #times(n, factorial(#minus(n, 1)))) ]
) 
factorial(10) ==> 3628800
#defq(ft, #lambda([ a, b ], #defq(c, a), #defq(d, b), #plus(c, d))) ==> #closure0(
  args: [ a, b ]
  body: [ #defq(c, a), #defq(d, b), #plus(c, d) ]
) 
ft(50, 5) ==> 55
#defq(v, #list(7, 8, "hello")) ==> [ 7, 8, "hello" ]
#ref(v, 0) ==> 7
#ref(v, 2) ==> "hello"
#defq(aa, #assoc(one: 1, two: 2, three: 3)) ==> { 
  one : 1,
  three : 3,
  two : 2
} 
#defq(ix, #quote(two)) ==> two
#ref(aa, #quote(one)) ==> 1
#ref(aa, ix) ==> 2
#ref(aa, #quote(three)) ==> 3
#refq(aa, one) ==> 1
#refq(aa, two) ==> 2
#refq(aa, three) ==> 3
#cat(aa, #assoc(four: "FOUR")) ==> { 
  four : "FOUR",
  one : 1,
  three : 3,
  two : 2
} 
#cat(aa, #assoc(two: "TWO")) ==> error; duplicate key ignored: two
{ 
  one : 1,
  three : 3,
  two : 2
} 
#list(3: 99, 0: "test") ==> [ 0: "test", #undefined, #undefined, 99 ] 
#defq(list, #list(1, 2, 3)) ==> [ 1, 2, 3 ]
#ref(list, 0) ==> 1
#refq(list, 0) ==> 1
#cat("abc", "def") ==> "abcdef"
#ref("abcdef", 2) ==> "c"
#defq(array1, #list(1, 2, 3, 4, 5, 6)) ==> [ 1, 2, 3, 4, 5, 6 ]
#ref(array1, 0) ==> 1
#ref(array1, 3) ==> 4
#ref(array1, 3 .. 4) ==> [ 4, 5 ]
#defq(a, #list(0 .. #minus(10, 1): #t)) ==> [ 0: #t, #t, #t, #t, #t, #t, #t, #t, #t, #t ] 
#defq(j, 5) ==> 5
#cat(#ref(a,  .. 4), #list(#f), #ref(a, 6 .. )) ==> [ 0: #t, #t, #t, #t, #t, #f, #t, #t, #t, #t ] 
#cat(#ref(a,  .. #minus(j, 1)), #list(#f), #ref(a, #plus(j, 1) .. )) ==> [ 0: #t, #t, #t, #t, #t, #f, #t, #t, #t, #t ] 
#defq(f, #defq(g, 9)) ==> 9
#plus(g, f, 12) ==> 30
#minus(#plus(g, f, 12), 30) ==> 0
#bitxor(2, #quotient(50, 2)) ==> error; not a function: #undefined
undefined ==> #undefined
#defq(io, #use("io")) ==> { 
  getline : #cfun0(),
  print : #cfunN(),
  println : #cfunN(),
  read : #cfun0(),
  write : #cfunN()
} 
#defq(text1, "ECHO") ==> "ECHO"
#defq(text2, "DELTA") ==> "DELTA"
#defq(invoke, #lambda([ fn ], #defq(text1, "BOB"), #defq(text2, "CAROLINE"), fn(), text2)) ==> #closure0(
  args: [ fn ]
  body: [ #defq(text1, "BOB"), #defq(text2, "CAROLINE"), fn(), text2 ]
) 
invoke(#lambda([], #refq(io, println)("case 1 is ", text1, " and ", text2))) ==> case 1 is ECHO and DELTA
"CAROLINE"
#defq(func, #lambda([], #defq(text1, "ALICE"), invoke(#lambda([], #refq(io, println)("case 2 is ", text1, " and ", text2))))) ==> #closure0(
  args: []
  body: [ #defq(text1, "ALICE"), invoke(#lambda([], #refq(io, println)("case 2 is ", text1, " and ", text2))) ]
) 
func() ==> case 2 is ALICE and DELTA
"CAROLINE"
#lambda([ text2 ], invoke(#lambda([], #refq(io, println)("case 3 is ", text1, " and ", text2))))("ZZZ") ==> case 3 is ECHO and ZZZ
"CAROLINE"
-3 ==> -3
#times(12345678.901234, 100000) ==> 1234567890123.4
#plus(#quotient(1, 2), 1/3) ==> 5/6
#plus(#quotient(1.0, 2), 1/3) ==> 0.833333333333333
#minus(#quotient(1, 2), 0.5) ==> 0.0
#defq(m, #use("math")) ==> { 
  abs : #cfun1(),
  acos : #cfun1(),
  asin : #cfun1(),
  atan : #cfun1(),
  atan2 : #cfun2(),
  ceil : #cfun1(),
  cos : #cfun1(),
  div : #cfun2(),
  e : 2.71828182845905,
  floor : #cfun1(),
  int : #cfun1(),
  log : #cfun1(),
  log10 : #cfun1(),
  mod : #cfun2(),
  pi : 3.14159265358979,
  pow : #cfun2(),
  sin : #cfun1(),
  sqrt : #cfun1(),
  tan : #cfun1()
} 
#refq(m, sqrt)(2) ==> 1.4142135623731
#refq(m, sqrt)(-2) ==> error; no real square root
#refq(m, e) ==> 2.71828182845905
#refq(m, sin)(#quotient(#refq(m, pi), 2)) ==> 1.0
#refq(m, tan)(#quotient(#refq(m, pi), 4)) ==> 1.0
#refq(m, tan)(#quotient(#refq(m, pi), 2)) ==> 1.63312393531954e+16
#refq(m, atan)(9999999999999) ==> 1.5707963267948
#refq(m, pow)(10, 9) ==> 1000000000.0
#refq(m, pow)(10, 90) ==> 1e+90.0
#refq(m, pow)(10, 900) ==> error; pow out of range
#refq(m, pow)(-10, 9) ==> -1000000000.0
#refq(m, pow)(10, -9) ==> 1e-09.0
#refq(m, abs)(-12.34) ==> 12.34
#refq(m, abs)(-12) ==> 12
#refq(m, abs)(-6/17) ==> 6/17
#refq(m, int)(12.1) ==> 12
#refq(m, int)(12.6) ==> 13
#refq(m, int)(-12.1) ==> -12
#refq(m, int)(-12.6) ==> -13
#refq(m, int)(10/3) ==> 3
#refq(m, int)(11/3) ==> 4
#lt("a", "b", "c") ==> #t
#lt("aa", "a") ==> #f
#lt("b", "a", "x") ==> #f
#defq(as, "abc") ==> "abc"
#defq(al, #list(1, 2, 3)) ==> [ 1, 2, 3 ]
#defq(av, #list(0: 1, 2, 3)) ==> [ 0: 1, 2, 3 ] 
#ref(as, 2 .. ) ==> "c"
#ref(al, 2 .. ) ==> [ 3 ]
#ref(av, 2 .. ) ==> [ 0: 3 ] 
#ref(as, 3 .. ) ==> ""
#ref(al, 3 .. ) ==> []
#ref(av, 3 .. ) ==> []
#ref(as, 4 .. ) ==> error; string range out of bounds: 4
#ref(al, 4 .. ) ==> error; list index out of bounds: 4
#ref(av, 4 .. ) ==> error; vector range out of bounds: 4
#ref(as, 2 .. 2) ==> "c"
#ref(al, 2 .. 2) ==> [ 3 ]
#ref(av, 2 .. 2) ==> [ 0: 3 ] 
#ref(as, 2 .. 3) ==> error; string range out of bounds: 3
#ref(al, 2 .. 3) ==> error; list range out of bounds: 3
#ref(av, 2 .. 3) ==> error; vector range out of bounds: 3
#ref(as, 3 .. 3) ==> error; string range out of bounds: 3
#ref(al, 3 .. 3) ==> error; list range out of bounds: 3
#ref(av, 3 .. 3) ==> error; vector range out of bounds: 3
#cat(#list(0: 1, 2, 3), #list(0: 4, 5)) ==> [ 0: 1, 2, 3, 4, 5 ] 
#cat(#list(1, 2, 3), #list(4, 5)) ==> [ 1, 2, 3, 4, 5 ]
#include("qsort.fun") ==> #closure0(
  args: [ list ]
  body: [ #defq(pivot, #if(#noteq(list, #list()), list(0))), #defq(q, #lambda([ list, first, last ], #if(#eq(list, #list()), #cat(qsort(first), #list(pivot), qsort(last)), #if(#lt(list(0), pivot), q(#ref(list, 1 .. ), #cat(list(0 .. 0), first), last), q(#ref(list, 1 .. ), first, #cat(list(0 .. 0), last)))))), #if(#le(#length(list), 1), list, q(#ref(list, 1 .. ), #list(), #list())) ]
) 
qsort(#list(5, 2, 7, 6, 3, 9, 12, 99, 1)) ==> [ 1, 2, 3, 5, 6, 7, 9, 12, 99 ]
qsort(#list("the", "quick", "brown", "fox", "jumps", "over", "a", "lazy", "dog")) ==> [ "a", "brown", "dog", "fox", "jumps", "lazy", "over", "quick", "the" ]
#defq(max, 9223372036854775807) ==> 9223372036854775807
#plus(max, 1) ==> error; numerical overflow
#minus(max) ==> -9223372036854775807
#minus(#minus(max), 1) ==> -9223372036854775808
#minus(#minus(max), 2) ==> error; numerical overflow
#refq(m, abs)(#minus(max)) ==> 9223372036854775807
#refq(m, abs)(#minus(#minus(max), 1)) ==> error; numerical overflow
#refq(m, int)(9.22337203685477e+18) ==> 9223372036854769664
#refq(m, int)(9.22337203685478e+18) ==> error; numerical overflow
#refq(m, int)(9.22337203685478e+18) ==> error; numerical overflow
#refq(m, int)(9.22337203685478e+18) ==> error; numerical overflow
#refq(m, int)(9.223372036855e+18) ==> error; numerical overflow
#refq(m, int)(-9.22337203685477e+18) ==> -9223372036854769664
#refq(m, int)(-9.22337203685478e+18) ==> error; numerical overflow
#refq(m, int)(3/2) ==> 2
#refq(m, int)(-3/2) ==> -2
#refq(m, int)(1/3) ==> 0
#refq(m, int)(2/3) ==> 1
#refq(m, int)(4/3) ==> 1
#refq(m, int)(5/3) ==> 2
#minus(-4, 1) ==> -5
#cat(#list(0: 1, 2, 3), #list(4, 5)) ==> [ 0: 1, 2, 3, 4, 5 ] 
#cat(#list(1, 2, 3), #list(0: 4, 5)) ==> [ 1, 2, 3, 4, 5 ]
qsort(#list(0: 5, 2, 7, 6, 3, 9, 12, 99, 1)) ==> [ 1, 2, 3, 5, 6, 7, 9, 12, 99 ]
#list(0 .. 3: 99, 100) ==> [ 0: 99, 99, 99, 99, 100 ] 
#list(0: 99, 3: 99, 100) ==> [ 0: 99, #undefined, #undefined, 99, 100 ] 
#list(0: 98,  .. 3: 99, 100) ==> [ 0: 98, 99, 99, 99, 100 ] 
#list(0: 98,  .. 3: 99, 100) ==> [ 0: 98, 99, 99, 99, 100 ] 
#list(0: 1.23, 2.34, 3: 3.14, 0: 2) ==> error; cannot redefine vector, index : 0
[ 0: 1.23, 2.34, #undefined, 3.14 ] 
#defq(messenger_builder, #lambda([ greeting ], #lambda([ who ], #refq(io, println)(greeting, " ", who)))) ==> #closure0(
  args: [ greeting ]
  body: [ #lambda([ who ], #refq(io, println)(greeting, " ", who)) ]
) 
#defq(hello_er, messenger_builder("Hello")) ==> #closure(
  args: [ who ]
  body: [ #refq(io, println)(greeting, " ", who) ]
  cont: #env(
    prev: []
    prog: []
    assoc: { 
        greeting : "Hello"
      } 
    cont: []
  )
) 
hello_er("world!") ==> Hello world!
#type("abc") ==> string
#type(hello_er) ==> closure
#type(list) ==> list
#type(1) ==> integer
#type(1.0) ==> real
#type(1/2) ==> ratio
#type(#quote(sym)) ==> symbol
#type(#type) ==> function
#type(#t) ==> boolean
#type(#void) ==> void
#type(akka) ==> undefined
#defq(time, #use("time")) ==> { 
  localtime : #cfun1(),
  mktime : #cfun1(),
  seconds : #cfun0(),
  sleep : #cfun1(),
  time : #cfunQ(),
  utctime : #cfun1()
} 
#refq(time, utctime)(1622447459.9024) ==> { 
  hour : 7,
  isdst : #f,
  mday : 31,
  min : 50,
  mon : 5,
  sec : 59.9024,
  wday : 1,
  yday : 150,
  year : 2021
} 
#defq(lt, #refq(time, localtime)(1622447459.9024)) ==> { 
  hour : 9,
  isdst : #t,
  mday : 31,
  min : 50,
  mon : 5,
  sec : 59.9024,
  wday : 1,
  yday : 150,
  year : 2021
} 
#refq(time, mktime)(lt) ==> 1622447459
